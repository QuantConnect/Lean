/*
 * QUANTCONNECT.COM - Democratizing Finance, Empowering Individuals.
 * Lean Algorithmic Trading Engine v2.0. Copyright 2014 QuantConnect Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
*/

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading;
using Newtonsoft.Json;
using QuantConnect.Algorithm.Framework.Signals;
using QuantConnect.Interfaces;
using QuantConnect.Logging;
using QuantConnect.Packets;

namespace QuantConnect.Lean.Engine.Signals
{
    /// <summary>
    /// Base signal handler that supports sending signals to the messaging handler
    /// </summary>
    public class DefaultSignalHandler : ISignalHandler
    {
        /// <inheritdoc />
        public bool IsActive => !_cancellationTokenSource.IsCancellationRequested;

        /// <summary>
        /// Gets the algorithm's unique identifier
        /// </summary>
        protected string AlgorithmId => Job.AlgorithmId;

        /// <summary>
        /// Gets whether or not the job is a live job
        /// </summary>
        protected bool LiveMode => Job is LiveNodePacket;

        /// <summary>
        /// Gets the algorithm job packet
        /// </summary>
        protected AlgorithmNodePacket Job { get; private set; }

        /// <summary>
        /// Gets the algorithm instance
        /// </summary>
        protected IAlgorithm Algorithm { get; private set; }

        /// <summary>
        /// Gets or sets the interval at which the signals are persisted
        /// </summary>
        protected TimeSpan PersistenceUpdateInterval { get; set; }

        /// <summary>
        /// Gets the signals generated by the algorithm
        /// </summary>
        protected ConcurrentDictionary<Guid, SignalAnalysisResult> SignalResults { get; } = new ConcurrentDictionary<Guid, SignalAnalysisResult>();

        private DateTime _nextPersistenceUpdate;
        private IMessagingHandler _messagingHandler;
        private CancellationTokenSource _cancellationTokenSource;
        private readonly ConcurrentQueue<Packet> _messages = new ConcurrentQueue<Packet>();

        /// <inheritdoc />
        public virtual void Initialize(AlgorithmNodePacket job, IAlgorithm algorithm, IMessagingHandler messagingHandler, IApi api)
        {
            Job = job;
            Algorithm = algorithm;
            _messagingHandler = messagingHandler;

            algorithm.SignalsGenerated += (algo, collection) => OnSignalsGenerated(collection);
        }

        /// <inheritdoc />
        public virtual void ProcessSynchronousEvents()
        {
            var algorithmUtcTime = Algorithm.UtcTime;
            foreach (var kvp in SignalResults)
            {
                var result = kvp.Value;
                var signalAge = algorithmUtcTime - result.Signal.GeneratedTimeUtc;

                // mark signals as closed after the period has elapsed
                if (result.Signal.Period <= signalAge)
                {
                    result.TimeUtc = algorithmUtcTime;
                    result.IsAnalysisClosed = true;
                }
            }
        }

        /// <inheritdoc />
        public virtual void Run()
        {
            _cancellationTokenSource = new CancellationTokenSource();

            // run until cancelled AND we're processing messages
            while (!_cancellationTokenSource.IsCancellationRequested || !_messages.IsEmpty)
            {
                try
                {
                    ProcessAsynchronousEvents();
                }
                catch (Exception err)
                {
                    Log.Error(err);
                    throw;
                }

                Thread.Sleep(50);
            }
        }

        /// <summary>
        /// Performs asynchronous processing, including broadcasting of signals to messaging handler
        /// </summary>
        protected virtual void ProcessAsynchronousEvents()
        {
            Packet packet;
            while (_messages.TryDequeue(out packet))
            {
                _messagingHandler.Send(packet);
            }

            if (DateTime.UtcNow > _nextPersistenceUpdate)
            {
                SaveSignalResults();
                _nextPersistenceUpdate = DateTime.UtcNow + PersistenceUpdateInterval;
            }
        }

        /// <summary>
        /// Save signal results to persistent storage
        /// </summary>
        protected virtual void SaveSignalResults()
        {
            // default save all results to disk
            var results = GetSignalResultsInRange(DateTime.MinValue, DateTime.MaxValue).ToList();
            var path = Path.Combine(Directory.GetCurrentDirectory(), AlgorithmId, "signal-results.json");
            Directory.CreateDirectory(new FileInfo(path).DirectoryName);
            File.WriteAllText(path, JsonConvert.SerializeObject(results, Formatting.Indented));
        }

        /// <summary>
        /// Handles the algorithm's <see cref="IAlgorithm.SignalsGenerated"/> event
        /// and broadcasts the new signal using the messaging handler
        /// </summary>
        protected virtual void OnSignalsGenerated(SignalCollection collection)
        {
            Enqueue(new SignalPacket(AlgorithmId, collection));

            foreach (var signal in collection.Signals)
            {
                SignalResults[signal.Id] = new SignalAnalysisResult
                {
                    Signal = signal,
                    IsAnalysisClosed = false,
                    Score = GetSignalScore(signal),
                    TimeUtc = collection.DateTimeUtc
                };
            }
        }

        /// <summary>
        /// Gets the signal results within the specified range ordered by <see cref="SignalAnalysisResult.TimeUtc"/>
        /// </summary>
        /// <param name="startUtc">The start of the range</param>
        /// <param name="endUtc">The end of the range</param>
        /// <returns>The signal analysis results that were either created or had score updates within the range</returns>
        protected IEnumerable<SignalAnalysisResult> GetSignalResultsInRange(DateTime startUtc, DateTime endUtc)
        {
            return SignalResults.Values
                .Where(result => result.TimeUtc >= startUtc && result.TimeUtc <= endUtc)
                .OrderBy(result => result.TimeUtc);
        }

        /// <summary>
        /// Gets the object holding the signal's score. It is expected that this object
        /// reference will be updated with the results from any signal analysis
        /// </summary>
        /// <param name="signal">The signal</param>
        /// <returns>A new instance of <see cref="SignalScore"/> used to track the signal's accuracy</returns>
        protected virtual SignalScore GetSignalScore(Signal signal)
        {
            return new SignalScore(0, 0);
        }

        /// <summary>
        /// Enqueues a packet to be processed asynchronously
        /// </summary>
        /// <param name="packet">The packet</param>
        protected void Enqueue(Packet packet)
        {
            _messages.Enqueue(packet);
        }

        /// <inheritdoc />
        public void Exit()
        {
            _cancellationTokenSource.Cancel(false);
        }
    }
}